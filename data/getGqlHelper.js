/**
 * Little script build src/gqlHelper.js from a template
 * to which application specific variables are applied.
 */

const fs = require('fs');
const path = require('path');
const {
  getGqlSetupFromConfigParams,
  getGqlSetupFromDictionary,
  loadConfigParams,
  loadDictionary,
} = require('./dictionaryHelper.js');

const dictPath = `${__dirname}/dictionary.json`;
if (!fs.existsSync(dictPath)) {
  console.error(
    `ERR: ${dictPath} does not exists - npm run schema - bailing out`
  );
  process.exit(2);
}

let dictionary;
try {
  dictionary = loadDictionary();
} catch (err) {
  console.error(`Error loading dictionary at ${dictPath}`, err);
  process.exit(3);
}

const gqlSetupFromDict = getGqlSetupFromDictionary(dictionary);
if (!gqlSetupFromDict) {
  console.error('ERR: unable to interpret data/dictionary.json - baling out');
  process.exit(4);
}

const params = loadConfigParams();
const gqlSetupFromParams = getGqlSetupFromConfigParams(params);
if (!gqlSetupFromParams) {
  console.error('ERR: unable to interpret data/parameters.js - baling out');
  process.exit(4);
}

const gqlSetup = Object.assign(gqlSetupFromParams, gqlSetupFromDict);
console.error(gqlSetup);

if (process.argv.length > 2 && process.argv[2].match(/^-+h(elp)?$/)) {
  console.log(`
  Generator for dictionary-dependent gql for the data-portal.
  Relayjs validates gql at compile time.
  Typical use:
      node data/getGqlHelper.js > src/gqlHelper.js
  `);
} else {
  const { boardCounts, chartCounts, fileTypeList, projectDetails } = gqlSetup;

  // template
  const template = `//
// !!! DO NOT EDIT !!!!
//
// This file was auto-generated by: node data/getGqlHelper.js
//

import { graphql } from 'react-relay';


/**
 * gql database
 */
const helperSingleton = {
  submissionPageQuery: graphql\`query gqlHelperSubmissionPageQuery {
    projectList: project(first: 10000) {
      name: project_id
      code
    }
    ${boardCounts.map((c, i) => `count${i}: ${c}`).join('\n    ')}
    ${fileTypeList.map((t, i) => `fileCount${i}: _${t}_count`).join('\n    ')}
  }\`,

  projectDetailQuery: graphql\`query gqlHelperProjectDetailQuery( $name: [String] ) {
    project( project_id:$name ) {
      name: project_id
      code
    }
    ${projectDetails
      .map((c, i) => `count${i}: ${c}( project_id:$name )`)
      .join('\n    ')}
    ${chartCounts
      .map((c, i) => `chart${i}: ${c}( project_id:$name )`)
      .join('\n    ')}
    ${fileTypeList
      .map((t, i) => `fileCount${i}: _${t}_count( project_id:$name )`)
      .join('\n    ')}
  }\`,

  explorerPageQuery: graphql\`query gqlHelperExplorerPageQuery{
    viewer {
      ...gqlHelperExplorerFragment
    }
  }\`,

  explorerPageFragment: graphql\`
  fragment gqlHelperExplorerFragment on viewer
  @argumentDefinitions(
    ${fileTypeList
      .map(
        (t) => `firstValue_${t}: {type: "Int", defaultValue: 100},
    cursor_${t}: {type: "Int"},`
      )
      .join('\n    ')}
    selected_projects: {type: "[String]"},
    selected_file_types: {type: "[String]"},
    selected_file_formats: {type: "[String]"}
  )
  {
    ${fileTypeList
      .map(
        (t) => `fileData_${t}: ${t} (
      first: $firstValue_${t},
      offset: $cursor_${t},
      project_id: $selected_projects,
      data_type: $selected_file_types,
      data_format: $selected_file_formats
    ) {
      project_id
      object_id
      file_name
      data_category
      data_format
      data_type
      file_size
    }`
      )
      .join('\n    ')}
  }
  \`,
  explorerRefreshQuery: graphql\`
    query gqlHelperExplorerRefreshQuery (
      ${fileTypeList
        .map(
          (t) => `$firstValue_${t}: Int,
      $cursor_${t}: Int,`
        )
        .join('\n      ')}
      $selected_projects: [String],
      $selected_file_types: [String],
      $selected_file_formats: [String]
    )
    {
      viewer {
        ...gqlHelperExplorerFragment @arguments(
          ${fileTypeList
            .map(
              (t) => `firstValue_${t}: $firstValue_${t},
          cursor_${t}: $cursor_${t},`
            )
            .join('\n          ')}
          selected_projects: $selected_projects,
          selected_file_types: $selected_file_types,
          selected_file_formats: $selected_file_formats
        )
      }
    }
  \`,
  allSubmitterIdsByTypeQuery: graphql\`
    query gqlHelperAllSubmitterIdsByTypeQuery( $project_id: [String] ) {
      core_metadata_collection(project_id:$project_id, first:0) {
        submitter_id
      }
    }
  \`,
};


//----------------------------------------------

/**
 * App-aware GQLHelper - delegates to the appropriate helper for the given app
 * based on a compile-time transformation. Relay does not like gql that
 * does not conform to the schema supplied to the relay compiler, so to
 * support different dictionaries in the same app we need to be a little
 * bit clever.
 */
export default class GQLHelper {
  /**
   * Goofy little utility - scans data for keys matching 'fileCount\\d+' or 'fileData\\d+',
   * and returns a { fileCount: sum-of-fileCounts, fileData:[] concatenation of data }
   *
   * @param {Object} data
   * @return {fileCount:sum,fileData:Array}
   */
  static extractFileInfo(data) {
    const fileCount = Object.keys(data).filter(key => key.indexOf('fileCount') === 0).map(key => data[key])
      .reduce((acc, it) => acc + it, 0);
    const fileData = Object.keys(data).filter(key => key.indexOf('fileData') === 0).map(key => data[key])
      .reduce(
        (acc, it) => {
          let result = acc;
          if (Array.isArray(it)) {
            result = acc.concat(it);
          } else {
            acc.push(it);
          }
          return result;
        }, []);
    return { fileCount, fileData };
  }

  static extractFileDataToDict(data) {
    return Object.keys(data).filter(key => key.indexOf('fileData') === 0).reduce(
      (acc, key) => {
        acc[key.substr(key.indexOf('_') + 1)] = data[key];
        return acc;
      }, {},
    );
  }

  /**
   * Little singleton factory
   */
  static getGQLHelper() {
    return helperSingleton;
  }

  static getExplorerVariables(selectedFilters, pageSize, cursors) {
    return {
      ${fileTypeList
        .map(
          (t) => `firstType_${t}: pageSize,
      cursor_${t}: ('${t}' in cursors) ? cursors.${t} : 0,`
        )
        .join('\n      ')}
      selected_projects: selectedFilters ? selectedFilters.projects : [],
      selected_file_formats: selectedFilters ? selectedFilters.file_formats : [],
      selected_file_types: selectedFilters ? selectedFilters.file_types : [],
    };
  }

  static getDefaultDictionary(data, cursors) {
    const fileLengthData = Object.keys(data).filter(key => key.indexOf('fileData') === 0).reduce(
      (map, key) => {
        const res = map;
        res[key.substr(key.indexOf('_') + 1)] = data[key].length; return res;
      }, {},
    );
    return Object.keys(fileLengthData).reduce(
      (map, key) => {
        const res = map;
        if (key in cursors) {
          res[key] = cursors[key];
        } else {
          res[key] = 0;
        }
        return res;
      }, {},
    );
  }

  static updateOffset(data, cursors) {
    const fileLengthData = Object.keys(data).filter(key => key.indexOf('fileData') === 0).reduce(
      (map, key) => {
        const res = map;
        res[key.substr(key.indexOf('_') + 1)] = data[key].length; return res;
      }, {},
    );
    return Object.keys(fileLengthData).reduce(
      (map, key) => {
        const res = map;
        if (key in cursors) {
          res[key] = cursors[key] + fileLengthData[key];
        } else {
          res[key] = fileLengthData[key];
        }
        return res;
      }, {},
    );
  }
} 
`;
  const gqlHelperPath = path.resolve(__dirname, '../src/gqlHelper.js');
  fs.writeFileSync(gqlHelperPath, template);
}
